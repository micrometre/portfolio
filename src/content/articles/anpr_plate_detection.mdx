---
title: 'ANPR Series: Advanced Plate Detection Engine'
description: 'Build a robust license plate detection system using advanced computer vision techniques, geometric filtering, and texture analysis.'
pubDate: 2024-12-16
tags: ['Python', 'OpenCV', 'Computer Vision', 'ANPR', 'Machine Learning', 'Image Processing']
image: '/anpr_plate_detection_3_0.png'
featured: true
---

# ANPR Plate Detection Engine: Advanced Techniques

This comprehensive guide demonstrates building a sophisticated license plate detection system using advanced computer vision techniques. We'll implement geometric filtering, aspect ratio validation, and edge density analysis to accurately identify license plates in complex scenes.

**Outline:**
1. Import Required Libraries
2. Load and Preprocess the Input Image
3. Detect Contours
4. Geometric Filtering and Aspect Ratio Validation
5. Edge Density and Texture Analysis
6. Visualize Detected Plate Candidates
7. Performance Optimization Tips

---

## 1. Import Required Libraries

We start with essential computer vision libraries and define helper classes for robust plate detection.

```python
import cv2
import numpy as np
import matplotlib.pyplot as plt
import logging
from typing import List, Tuple, Dict
from dataclasses import dataclass
from enum import Enum

# For notebook display
%matplotlib inline

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)
```

## 2. Load and Preprocess the Input Image

We load the input image and apply preprocessing using the pipeline from our previous article on image preprocessing.

```python
# Load the image (replace with your image path)
image_path = './sample_images/sample_image6.jpg'  # Update this path as needed
image = cv2.imread(image_path)

if image is None:
    raise FileNotFoundError(f"Image not found at {image_path}. Please check the path.")

# Display the original image
image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
plt.figure(figsize=(8, 6))
plt.imshow(image_rgb)
plt.title('Original Input Image')
plt.axis('off')
plt.show()

# Apply preprocessing pipeline
preprocessed = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
preprocessed = cv2.adaptiveThreshold(preprocessed, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 11, 2)

plt.figure(figsize=(8, 6))
plt.imshow(preprocessed, cmap='gray')
plt.title('Preprocessed Image (Adaptive Binary Threshold)')
plt.axis('off')
plt.show()
```

![Original Input Image](/anpr_plate_detection_3_0.png)

![Preprocessed Binary Image](/anpr_plate_detection_3_1.png)

## 3. Detect Contours

The first step in plate detection is finding all contours in the preprocessed binary image. These contours represent potential objects of interest.

```python
# Find contours in the preprocessed image
contours, _ = cv2.findContours(preprocessed, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Draw all contours on the image for visualization
contour_img = image_rgb.copy()
cv2.drawContours(contour_img, contours, -1, (0, 255, 0), 2)

plt.figure(figsize=(8, 6))
plt.imshow(contour_img)
plt.title('All Contours Detected')
plt.axis('off')
plt.show()

print(f"Number of contours found: {len(contours)}")
```

![All Contours Detected](/anpr_plate_detection_5_0.png)

## 4. Geometric Filtering and Aspect Ratio Validation

License plates have characteristic geometric properties. We filter contours based on:
- **Area**: Plates must have sufficient size
- **Aspect ratio**: Plates are typically 2-8 times wider than they are tall
- **Dimensions**: Reasonable width and height bounds

```python
# Geometric constraints for license plate detection
min_area = 200      # Minimum area to be considered
max_area = 60000    # Maximum area to avoid false positives
min_width = 40      # Minimum width in pixels
max_width = 1000    # Maximum width in pixels
min_height = 10     # Minimum height in pixels
max_height = 300    # Maximum height in pixels
aspect_ratio_range = (2.0, 8.0)  # Width/height ratio range

candidates = []
print("Analyzing contour properties (x, y, w, h, area, aspect_ratio):")

for i, contour in enumerate(contours):
    x, y, w, h = cv2.boundingRect(contour)
    area = cv2.contourArea(contour)
    aspect_ratio = w / h if h > 0 else 0
    
    # Apply geometric filters
    if (min_area <= area <= max_area and
        min_width <= w <= max_width and
        min_height <= h <= max_height and
        aspect_ratio_range[0] <= aspect_ratio <= aspect_ratio_range[1]):
        candidates.append((x, y, w, h, aspect_ratio, area, contour))
        print(f"  Candidate {len(candidates)}: ({x}, {y}, {w}, {h}, {area:.1f}, {aspect_ratio:.2f})")

# Draw candidate bounding boxes
candidate_img = image_rgb.copy()
for (x, y, w, h, aspect_ratio, area, contour) in candidates:
    cv2.rectangle(candidate_img, (x, y), (x + w, y + h), (255, 0, 0), 2)
    cv2.putText(candidate_img, f"AR: {aspect_ratio:.1f}", (x, y-5), 
                cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255,0,0), 1)

plt.figure(figsize=(8, 6))
plt.imshow(candidate_img)
plt.title('Geometric Filtered Plate Candidates')
plt.axis('off')
plt.show()

print(f"Number of geometric candidates: {len(candidates)}")
```

![Geometric Filtered Candidates](/anpr_plate_detection_7_1.png)

## 5. Edge Density and Texture Analysis

License plates contain text characters, which create distinctive edge patterns. We analyze edge density to validate candidates:

```python
# Edge density analysis parameters
edge_density_threshold = (0.1, 0.8)  # Acceptable density range for plates
final_candidates = []

print("Analyzing edge density for each candidate:")
for i, (x, y, w, h, aspect_ratio, area, contour) in enumerate(candidates):
    # Extract region of interest
    roi = preprocessed[y:y+h, x:x+w]
    
    # Apply Canny edge detection to ROI
    edges = cv2.Canny(roi, 50, 150)
    
    # Calculate edge density
    edge_pixels = np.sum(edges > 0)
    total_pixels = roi.shape[0] * roi.shape[1]
    density = edge_pixels / total_pixels if total_pixels > 0 else 0
    
    print(f"  Candidate {i+1}: Edge density = {density:.3f}")
    
    # Filter by edge density
    if edge_density_threshold[0] < density < edge_density_threshold[1]:
        final_candidates.append((x, y, w, h, density))
        print(f"    → ACCEPTED (good edge density)")
    else:
        print(f"    → REJECTED (edge density outside range)")

# Draw final candidates with density values
final_img = image_rgb.copy()
for i, (x, y, w, h, density) in enumerate(final_candidates):
    cv2.rectangle(final_img, (x, y), (x + w, y + h), (0, 255, 0), 3)
    cv2.putText(final_img, f"Plate {i+1}", (x, y-20), 
                cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0,255,0), 2)
    cv2.putText(final_img, f"Density: {density:.3f}", (x, y-5), 
                cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0,255,0), 1)

plt.figure(figsize=(8, 6))
plt.imshow(final_img)
plt.title('Final Plate Candidates (After Edge Density Analysis)')
plt.axis('off')
plt.show()

print(f"\\nFinal result: {len(final_candidates)} plate candidates detected")
```

![Edge Density Analysis](/anpr_plate_detection_9_0.png)

## 6. Visualize Detected Plate Candidates

Here are our final detected license plate candidates, ranked by confidence:

```python
# Display the final results with enhanced visualization
plt.figure(figsize=(12, 8))
plt.imshow(final_img)
plt.title('ANPR Plate Detection Results', fontsize=16, fontweight='bold')
plt.axis('off')

# Add result summary
if final_candidates:
    result_text = f"✅ Detection Complete: {len(final_candidates)} license plate(s) found"
    plt.figtext(0.5, 0.02, result_text, ha='center', fontsize=12, 
                bbox=dict(boxstyle="round,pad=0.3", facecolor="lightgreen", alpha=0.7))
else:
    plt.figtext(0.5, 0.02, "❌ No license plates detected in this image", 
                ha='center', fontsize=12,
                bbox=dict(boxstyle="round,pad=0.3", facecolor="lightcoral", alpha=0.7))

plt.tight_layout()
plt.show()
```

![Final Detection Results](/anpr_plate_detection_11_0.png)

## 7. Performance Optimization Tips

For production systems, consider these optimizations:

### Multi-Scale Detection
```python
def multi_scale_detection(image, scales=[0.5, 1.0, 1.5]):
    """Detect plates at multiple scales for better accuracy"""
    all_candidates = []
    for scale in scales:
        if scale != 1.0:
            h, w = image.shape[:2]
            scaled = cv2.resize(image, (int(w*scale), int(h*scale)))
            # Apply detection pipeline to scaled image
            # Scale coordinates back to original image
        else:
            # Apply detection to original image
            pass
    return all_candidates
```

### Non-Maximum Suppression
```python
def non_max_suppression(candidates, overlap_threshold=0.3):
    """Remove overlapping detections"""
    if not candidates:
        return []
    
    # Sort by confidence/area
    candidates = sorted(candidates, key=lambda x: x[5], reverse=True)  # Sort by area
    
    keep = []
    while candidates:
        current = candidates.pop(0)
        keep.append(current)
        
        # Remove overlapping candidates
        candidates = [c for c in candidates if calculate_overlap(current, c) < overlap_threshold]
    
    return keep
```

### Confidence Scoring
```python
def calculate_confidence_score(candidate):
    """Calculate confidence score based on multiple factors"""
    x, y, w, h, aspect_ratio, area, density = candidate
    
    # Aspect ratio score (closer to 4.5 is better)
    ar_score = 1.0 - abs(aspect_ratio - 4.5) / 4.5
    
    # Size score (moderate sizes are better)
    size_score = min(area / 5000, 5000 / area) if area > 0 else 0
    
    # Edge density score
    density_score = density if 0.2 <= density <= 0.6 else (1.0 - abs(density - 0.4))
    
    # Combined confidence
    confidence = (ar_score * 0.4 + size_score * 0.3 + density_score * 0.3)
    return min(max(confidence, 0), 1)  # Clamp to [0,1]
```

## Conclusion

This advanced plate detection system combines multiple computer vision techniques:

1. **Geometric filtering** eliminates obviously non-plate objects
2. **Aspect ratio validation** focuses on rectangular plate-like shapes
3. **Edge density analysis** confirms the presence of text characters
4. **Multi-stage validation** reduces false positives

### Key Advantages:
- ✅ **Robust**: Works with various lighting conditions and angles
- ✅ **Fast**: Efficient filtering reduces computation time
- ✅ **Accurate**: Multi-stage validation minimizes false positives
- ✅ **Configurable**: Parameters can be tuned for different regions/plate types

### Next Steps:
1. **Character Segmentation**: Isolate individual characters from detected plates
2. **OCR Recognition**: Convert character images to text
3. **Post-processing**: Validate and correct recognized text
4. **Real-time Processing**: Optimize for video streams

For the complete ANPR pipeline, check out the next articles in this series covering character segmentation and OCR recognition techniques.
